set show timing off .

fmod A-UNIF is
  sorts List Elt .
  subsort Elt < List .
  op __ : List List -> List [assoc] .
  op f : List List -> List [assoc] .
  op g : List List -> List .
  op h : List List -> List [assoc comm] .
  op i : List -> List .
  op j : List List -> List [assoc comm id: 1] .
  op 1 : -> List .
  ops a b c d e : -> Elt .
  vars A B C D
       G H I J K L M N
       P Q R S T U V W X Y Z : List .
  vars E F : Elt .
endfm


*** linear elementary associative unification of n variables against m variables
*** has a minimal complete set of unifiers of size D(n, m)

***( Delannoy's numbers D(n, m)

1       1       1       1       1       1       1       1       1       1       
1       3       5       7       9       11      13      15      17      19      
1       5       13      25      41      61      85      113     145     181     
1       7       25      63      129     231     377     575     833     1159    
1       9       41      129     321     681     1289    2241    3649    5641    
1       11      61      231     681     1683    3653    7183    13073   22363   
1       13      85      377     1289    3653    8989    19825   40081   75517   
1       15      113     575     2241    7183    19825   48639   108545  224143  
1       17      145     833     3649    13073   40081   108545  265729  598417  
1       19      181     1159    5641    22363   75517   224143  598417  1462563 

)

unify A B =? X .
unify A B =? X Y .
unify A B C =? X Y .
unify A B C =? X Y Z .
unify A B C D =? X Y Z .
unify A B C D G =? X Y Z .

*** Simultaneous elementary associative unification is just a product as each
*** equation is independent because of linearity

unify A B C =? X Y Z /\ G H I =? M N .

*** Non-linear problems are explicitly disallowed.

unify A B =? B C .

*** Non-variable subterms are allowed with the proviso:
*** [1] Each such subterm must be headed by a collapse free symbol; and
*** [2] No variable occuring directly under an associative symbol can be mentioned.

unify a A a =? B a C .
unify a A b =? B c C .
unify a A a =? B a C a D .
unify a A b =? B c C d D .

unify h(A, B, B) C h(G, H) =? I h(J, i(K)) L .
unify h(A, B) C h(G, H) =? I h(J, J) L h(M, M) N .
unify A h(X, Y) B =? C h(U, V) D h(U, U) G .

*** Because non-free theories introduce non-linear fresh variables for purification and expressing
*** unifiers, associative symbols can only appear at the top or immediately under the free skeleton
*** of a term.

unify g(h(A, B, B) C h(G, H), X Y a Z) =?
      g(I h(J, i(K)) L, U b V W) .

*** The AC theory introduces fresh variables to express the AC unifiers on abstracted terms
*** and these are necessarily non-linear [since each variable must show up on each side of the
*** equation] which breaks linear associative unification.

unify h(h(A, B, B) C h(G, H), X Y a Z) =?
      h(I h(J, i(K)) L, U b V W) .

***
*** New algorithm lifts many of the above restrictions, though variables occuring under an associative
*** symbol (perhaps indirectly via collapse) should still be linear, unless they are element variables
*** or are otherwise constrained. No more than two subterms headed by the same associative symbol should
*** the same variable unless at least for one of the terms has all the arguments are collapse-free
*** aliens or element variables.
***

unify h(A, A) =? h(f(B, C), f(I, J)) .
*** this is OK

unify h(A, A, A) =? h(f(B, C), f(I, J), f(X, Y)) .
*** this forces 3 h-terms to unify against A and fails

unify h(f(a, b), f(a, b), f(a, b)) =? h(f(B, C), f(I, J), f(X, Y)) .
*** this is OK

unify A E B F C E D =? W F X E Y F Z .
*** OK because the nonlinear variable are all element variables

unify A =? h(B, C) /\ X A Y =? U h(C, D) V E A W .
*** OK because A is bound to a collapse-free alien before the associative theory sees it

unify X A Y =? U h(C, D) V E A W /\ A =? h(B, C) .
*** Swapping the order fails

unify j(A, f(B, E, C), f(D, E, j(G, H), I)) =? j(U, f(V, W), f(X, j(Y, Z), S)) .
*** very complicated cases with collapse work as long as only element variables are nonlinear
